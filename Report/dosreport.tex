% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\begin{document}

\title{Casper CTF: Solutions}


\author{Siebe Dreesen}
\institute{}

\maketitle       

\section{Overview }
\begin{table}[]
\centering

\begin{tabular}{cll}
\multicolumn{1}{c|}{Level} & Password                                              & Time spent \\ \hline
\multicolumn{1}{c|}{3}     & \multicolumn{1}{l|}{mlHvsSM2qDSqIK1bOyixamw7O7igKdBF} & 10 minutes \\
\multicolumn{1}{c|}{4}     & \multicolumn{1}{l|}{HikOeJRoG2kYCI1QrHBf0bouflFWStPy} & 4 hours    \\
\multicolumn{1}{c|}{5}     & \multicolumn{1}{l|}{XRTOmu0ToSDrWsPMv7UFPqRcDJFUVf6E} & 8 hours    \\
\multicolumn{1}{c|}{6}     & \multicolumn{1}{l|}{vb56zXrIsjRPrpM81f5EsqnAjBKYnft8} & 5 hours    \\
\multicolumn{1}{c|}{61}    & \multicolumn{1}{l|}{}                                 &            \\
\multicolumn{1}{c|}{62}    & \multicolumn{1}{l|}{}                                 &            \\
\multicolumn{1}{c|}{63}    & \multicolumn{1}{l|}{}                                 &            \\
\multicolumn{1}{c|}{7}     & \multicolumn{1}{l|}{}                                 &            \\
\multicolumn{1}{c|}{8}     & \multicolumn{1}{l|}{}                                 &            \\ \hline
Total                      &                                                       &           
\end{tabular}
\end{table}

\section{Casper 4 solution}
\subsection{Description}
This program takes 1 argument as input, if more are given it will print the first argument and stop the program immediately. The program contains a struct which contains a buffer of 775 characters and a function pointer. When less then 2 arguments are given the first will be copied into the buffer of the struct using strcpy() and the function pointer will be called. Normally this function pointer will point to the greetUser function which will print given string.

\subsection{Vulnerability}
This program contains a memory management vulnerability, specifically a buffer overflow vulnerability where we can overwrite a function pointer. The struct contains a buffer and a function pointer which will be allocated underneath the buffer in memory. The function strcpy() which is unsafe will copy the first argument but does not do bounds checking. This means the buffer can be overflowed and the function pointer can be overwritten by giving an argument that is bigger than the allocated space for the buffer of 775 bytes. 

\subsection{Exploit description}
The vulnerability can be exploited by giving a well-chosen argument that is bigger than the buffer space and overwrites the function pointer. The argument contains shell code which will spawn the /bin/xh shell. The specific argument is build from the following bytes:
\begin{itemize}
	\item A NOP sled of 755 byte
	\item The shell code of 21 bytes
	\item Address in the sled which will be pointed to the shell code and overwrites the function pointer
\end{itemize}
This argument will be copied to the buffer and overwrite the function pointer with the right address. By using a NOP sled the exploit becomes more robust because any address in the sled can be called to execute the shell code. Note that to overflow the buffer actually 776 bytes are used because the buffer is allocated in memory as words which means 194 words = 776 bytes.

\subsection{Mitigation}
A possible mitigation would be to use strncpy() instead of srtcpy() which will only copy N characters and the buffer will never overflow. Other possible mitigations are non-executable data so that the shell code cannot be executed or address space layout randomisation which will make it harder to point to the right address of the shell code. Stack canaries would not work because they are inserted between the return address and the local variables, in our case only the local variables are changed.

\section{Casper 5 solution}
\subsection{Description}
This program again takes 1 input which is expected to be a username. The program copies this name to the dedicated buffer using the unsafe strcpy(). The program stores users in a struct containing a name and a pointer to a role which contains the name of the role and the authority level. If the user has authority level 1 the /bin/xh shell will run. The default role has authority 0.

\subsection{Vulnerability}
The vulnerability is again because of the unsafe strcpy() which let's the attacker possibly overwrite the role pointer to a role struct with authority 1 by overflowing the buffer. This will cause the shell to automatically execute.

\subsection{Exploit description}
I have chosen for a data-only attack by corrupting the role pointer. I did this by giving an argument which had 776 chars and 1 address (4 bytes). The random chars overflowed the allocated space for name causing the role pointer to be overwritten by the chosen address.  

This problem took longer than expected because I first tried to exploit this by letting this point to a custom role struct in the name part and letting the pointer point to that struct instead of the default. This did not work because you cannot give an argument with null bytes which are necessary to represent integer 1.

So the solution was to find a couple of bytes of the right length in the memory that already contained int 1 to represent the struct. I did this by searching in the c library. I was able to find an address which had 32 random bytes and then 4 bytes which represented 1. I gave this address as argument and the shell executed.

\subsection{Mitigation}
The easiest defence would again be to not use strcpy() but strncpy() instead, this would make sure the attacker cannot overflow the name by a given argument. An other mitigation would be to use address space layout randomisation which would make it very hard for the attacker to find the address of certain bytes that would have the role structure. Because it is a data-only attack non-executable data would not work as a mitigation.

\section{Casper 6 solution}
\subsection{Description}
In this program there again is a buffer of 775 bytes (actually 776 in memory) which will be filled with a given name by a user. The user can give input when the program executes gets() which reads characters of the input stream and adds a 0x00 byte at the end, this function is unsafe because the input can be as big as desired.

\subsection{Vulnerability}
The vulnerability is caused by the gets() function which does not do bounds checking. The attacker can overflow the buffer and overwrite the return address to the desired shell code. This is called call stack smashing.

\subsection{Exploit description}
This vulnerability can be exploited by given a well-chosen argument as input which contains shell code and overwrites the return address to the self written shell code. The shell code in this exploit will spawn the //bin/xh shell. A NOP sled will be used to add robustness, the return address wil be pointing to an address in this sled. The input:
\begin{itemize}
	\item NOP sled (0x90) of 755 bytes
	\item Shell code of 21 bytes
	\item 11 characters which fill up the space between the buffer and the return address
	\item The desired return address
\end{itemize}
Note that is necessary to insert characters because the memory dedicated for the frame pointer cannot be executed.

\subsection{Mitigation}
A possible mitigation for this would be stack canaries which would warn the system that the return address is overwritten. These are random words added between the local variables and the return address and are checked on changes when returning. Another possibility would be to enable non-executable data so that the shell code cannot be executed but this could be solved by using a code reuse attack instead. An easy solution would be to use a different function to read the input like fgets() which stops reading when the buffer is full. Also address space layout randomisation would again make it more difficult for the attacker.

\subsection{Advanced levels}

\section{Casper 7 solution}
\subsection{Description}
\subsection{Vulnerability}
\subsection{Exploit description}
\subsection{Mitigation}

\section{Casper 8 solution}
\subsection{Description}
\subsection{Vulnerability}
\subsection{Exploit description}
\subsection{Mitigation}

\end{document}
